////////////////////////////////////////////////////////////////////////////////
//	Zsiroskenyer Team
////////////////////////////////////////////////////////////////////////////////
//	Screen-space Ambient Occlusion.
//	AO data written to 1 channel output buffer
////////////////////////////////////////////////////////////////////////////////

#include "deferred_lightpass_cmn.cginc"

//------------------------------------------------------------------------------
//	Input textures (normal & depth)
//------------------------------------------------------------------------------

sampler2D normalTexture = {
    MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
sampler2D depthTexture = {
    MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};


//------------------------------------------------------------------------------
//	Shader I/O sturctures
//------------------------------------------------------------------------------

struct VS_IN {
	float3 posL 	: POSITION;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};



//------------------------------------------------------------------------------
//	Vertex shader
//------------------------------------------------------------------------------
VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}



float ProcessAO(float2 projtex)
{
/*
  float SSAOraylength = 5.000150f;
  float SSAOiterations = 2;

  // Try depth independency, but not expected result TODO...
  //float4 vsDeltaCoord  = float4(SSAOraylength, distance(camPos, GetWorldPosition(projtex, tex2D(depthBuffer, projtex).r)), 0, 1);

  // Transform that to proj space, then divide, transform x,y to texture space,  now ssao will be depth independent
  //float4 deltaCoord = mul(vsDeltaCoord, projMat);


  float SMAP_DX = (deltaCoord.x + 1) /  2 / 800; // MAGICS, TODO
  float SMAP_DY = SMAP_DX;

//Ambient Gyüjtés folyamat kezdete 0
 float ao = 0.0f;
                                                   //  . .
//Kiindulási pixel, normalja,pozíciója, és majd ezek körül mászkálunk négyzetekben..     . <- kiindulási pont
 float3 refpos = GetPosition(projtex);
 float3 refnorm = GetNormal(projtex);

 float SSAORadius = 2.0f;
 for (int j = 1; j <= SSAOiterations; ++j)
 {
   //8 körül levõ ponton mintavétel
   //kezdés bal felsõ sarok órajárás irányban..
   float2 coord1 = float2(-SMAP_DX,-SMAP_DY)*j * SSAORadius;
   float2 coord2 = float2(0       ,-SMAP_DY)*j * SSAORadius;
   float2 coord3 = float2(SMAP_DX ,-SMAP_DY)*j * SSAORadius;
   float2 coord4 = float2(SMAP_DX ,0       )*j * SSAORadius;
   float2 coord5 = float2(SMAP_DX ,SMAP_DY )*j * SSAORadius;
   float2 coord6 = float2(0       ,SMAP_DY )*j * SSAORadius;
   float2 coord7 = float2(-SMAP_DX,SMAP_DY )*j * SSAORadius;
   float2 coord8 = float2(-SMAP_DX,0       )*j * SSAORadius;


   ao+= doAmbientOcclusion(projtex,coord1,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord2,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord3,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord4,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord5,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord6,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord7,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord8,refpos,refnorm);


 } 
 
  float SSAOintensity = 1.5f;
  return (1.0f - (ao/SSAOiterations/8))*(SSAOintensity);
*/
return 0.0f;
}

//------------------------------------------------------------------------------
//	Pixel shader
//------------------------------------------------------------------------------
float PS_MAIN(VS_OUT In) : COLOR0 {
	// sample normal and depth
	float2 packedNormal = tex2D(normalTexture, In.tex0);
	float3 normal = UnpackNormal(packedNormal);
	float depth = tex2D(depthTexture, In.tex0);	
	
	// ! COMPUTE AO FROM "normal" AND "depth" ! //	
	return ProcessAO(float2(0.0f,0.0f));
};



technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}