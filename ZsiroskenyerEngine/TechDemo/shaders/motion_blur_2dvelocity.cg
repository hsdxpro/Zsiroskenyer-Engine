#include "common.cginc"

sampler2D depthTexture = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};


struct {
 float4x4 viewProj;
 float4x4 invViewProj;
 float4x4 prevViewProj;
 float3	  camPos;
 float	  nearPlane;
 float2	  InvframeDeltaTimeDiv2DivInputRes;
 float2	  minMaxPixelVel;
 float	  farPlane;
} c : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 		: SV_POSITION;
	float3 viewRayVS	: TEXCOORD0;
	float2 tex0 		: TEXCOORD1;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );

	// view ray
	float4 viewRay = mul(float4(Out.posH.xy, 1.0f, 1.0f), c.invViewProj);
	viewRay.xyz *= (1.0f / viewRay.w);
	viewRay.xyz -= c.camPos;
	Out.viewRayVS = viewRay.xyz * (1.0f / c.farPlane);
	return Out;
}

float2 PS_MAIN(VS_OUT In) : COLOR0 {

	// Current world pos
	float3 posW = GetWorldPosition(c.camPos, In.viewRayVS, tex2D(depthTexture , In.tex0).r, c.nearPlane, c.farPlane);

	// Current frame NDC
	float4 currPosH = posW.x * c.viewProj[0] + ( posW.y * c.viewProj[1] + (posW.z * c.viewProj[2] + c.viewProj[3]));
	currPosH.xyz /= currPosH.w;

	// Previous frame NDC position
	// x,y,w  // we not need the z component
	float3 prevPosH = float3(	dot(posW, float3(c.prevViewProj[0].x, c.prevViewProj[1].x, c.prevViewProj[2].x)) + c.prevViewProj[3].x,
								dot(posW, float3(c.prevViewProj[0].y, c.prevViewProj[1].y, c.prevViewProj[2].y)) + c.prevViewProj[3].y,
								dot(posW, float3(c.prevViewProj[0].w, c.prevViewProj[1].w, c.prevViewProj[2].w)) + c.prevViewProj[3].w );
	prevPosH.xy /= prevPosH.z; // .z now the W component !!!!
	

	// v   =             s               /       t        / magic number :)
	// Clamp the velocity, 1.0 depth make so large velocity that ruins the motion blur sampling
	return  clamp((currPosH.xy - prevPosH.xy) * c.InvframeDeltaTimeDiv2DivInputRes, c.minMaxPixelVel.x, c.minMaxPixelVel.y);
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}