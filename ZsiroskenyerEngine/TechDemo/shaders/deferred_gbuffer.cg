#include "common.cginc"
#include "deferred_gbuffer_material.cginc"

float4x4 wvp : register(c0);
float4x4 world : register(c4);
float3 camPos : register(c8);

sampler2D diffuseTex = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = WRAP,
	AddressV = WRAP,
};

sampler2D normalTex = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = WRAP,
	AddressV = WRAP,
};

struct VS_IN {
	float3 posL 	: POSITION;
	float3 normalL 	: NORMAL;
	float3 tangentL : COLOR0;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float3 normalW 	: TEXCOORD0;
	float3 tangentW	: TEXCOORD1;
	float2 tex0 	: TEXCOORD2;
	float3 posW 	: TEXCOORD3;
	float3x3 TBN	: TEXCOORD4;
};


//------------------------------------------------------------------------------
// Vertex shader
//------------------------------------------------------------------------------
VS_OUT VS_MAIN(VS_IN In) {
	VS_OUT Out;

	Out.posW = In.posL.x * world[0].xyz + ( In.posL.y * world[1].xyz + (In.posL.z * world[2].xyz) + world[3].xyz);
	Out.normalW = In.normalL.x* world[0].xyz + ( In.normalL.y * world[1].xyz + (In.normalL.z * world[2].xyz));
	Out.tangentW = In.tangentL.x* world[0].xyz + ( In.tangentL.y * world[1].xyz + (In.tangentL.z * world[2].xyz));
	Out.posH = In.posL.x * wvp[0] + ( In.posL.y * wvp[1] + (In.posL.z * wvp[2] + wvp[3]));

	Out.tex0 = In.tex0;

	// Calculate TBN base per vertex (CHEAP) (Tangent to World space)
		float3 N = normalize(Out.normalW);
		float3 T = normalize(Out.tangentW - dot(Out.tangentW,N) * N);
		float3 B = normalize(cross(N,T));
	Out.TBN = float3x3(T,B,N);
	return Out;
}


//------------------------------------------------------------------------------
// Vertex shader
//------------------------------------------------------------------------------
GBUFFER PS_MAIN(VS_OUT In) {
	GBUFFER Out;
	//Out = PixelShader_NormalMap(In.TBN, In.tex0);
	//return Out;
	
	//-----------------gBuffer0: DIFFUSECOLOR------------------//
	float4 diffuseColor = tex2D(diffuseTex, In.tex0);
	if (diffuseColor.a < 0.5f) {
		discard;
	}
	Out.diffuse.xyz = diffuseColor.xyz;

	//--------------------gBuffer1: NORMALS--------------------//
	// Normal map normals
	float3 n = normalize(mul(tex2D(normalTex, In.tex0).xyz * 2 - 1, In.TBN).xyz);

	// OR Geometry normals
	//float3 n = In.normalW;

	// Pack normals
	Out.normal.rg = PackNormal(n);

	//---------------gBuffer2: DEBUG PURPOSES------------------//
	// Buffer2 reserved for future use
	Out.misc = float4(0,0,0,1);
	return Out;
	
};

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}