#include "common.cginc"

sampler2D colorTexture : register( s0 ) = {
	MipFilter = LINEAR,
	MinFilter = LINEAR,
	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
 
sampler2D depthTexture : register( s1 ) = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D normalTexture : register( s2 ) = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

struct {
	float4x4	invViewProj;
	float4x4 	viewProj;
	float4x4 	view;
	float4x4 	invView;
	float3		camPos;
	float2		invOutputRes;
	float		farPlane;
	float		stepLength;
	float		maxRange;
} c : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: POSITION;
	float2 tex0 	: TEXCOORD0;
	float3 viewRayW  : TEXCOORD1;
};


VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );

	float4 viewRay = Out.posH.x * c.invViewProj[0] + (Out.posH.y * c.invViewProj[1] + (c.invViewProj[2] + c.invViewProj[3]));

	Out.viewRayW = viewRay.xyz * (1.0f / viewRay.w);
	Out.viewRayW -= c.camPos;

	return Out;
}


float4 PS_MAIN(VS_OUT In) : COLOR0 {
	/*
	float4 color = tex2D(colorTexture, In.tex0);
	float3 normalW = UnpackNormal(tex2D(normalTexture, In.tex0).xy);

	float3 reflectDirW = reflect(In.viewRayW / 2000.f, normalW);
	float3 reflectDirVS = mul(reflectDirW, (float3x3)c.view);
	float depth = tex2D(depthTexture, In.tex0).r;
	if(depth == 1.0f)
	{
		return float4(0,0,0,0);
	}

	float3 posW = GetWorldPosition(c.camPos, In.viewRayW, depth).xyz;

	float4 posH = mul(float4(posW + reflectDirW, 1.0f), c.viewProj);
	posH.xyz /= posH.w;

	float2 uvStep;
	uvStep.x = (posH.x + 1 ) *  1 / 2 - In.tex0.x;
	uvStep.y = (posH.y - 1 ) * -1 / 2 - In.tex0.y;
	uvStep = normalize(uvStep) * c.invOutputRes; // One Step max one pixel ! (quality)

	
	float3 posVS = mul(float4(posW, 1.f), c.view);
	float3 rayNormalVS = mul(reflectDirW, (float3x3)c.view);
	if(rayNormalVS.z < 0)
		return float4(0,0,0,0);

	rayNormalVS = normalize(float3(-rayNormalVS.z, rayNormalVS.y, rayNormalVS.x)); // Normal vector in view space that point far away
	
	int nMaxPixels = 60;
	float4 collectedReflectionColor = float4(0,0,0,0);
	
	float dx = ddx(In.tex0);
	float dy = ddy(In.tex0);

	float3 currSampledPosVS;
	float2 currUV;
	for(int i = 1; i < nMaxPixels; i++ )
	{
		currUV = In.tex0 + (float)i * uvStep;
		if( currUV.x > 1 || currUV.x < 0 || currUV.y > 1 ||currUV.y < 0)
		{
			break;
		}

		depth = tex2D(depthTexture, currUV, dx, dy).r;
		if(depth == 1.0f)
		{
			break;
		}

		currSampledPosVS = mul(float4(GetWorldPosition(c.camPos, In.viewRayW, depth).xyz, 1.f), c.view);

		// Mikor is van metszés ??!?!?!
		//if( reflectDirVS.x < 0)
		{
			//if( dot(rayNormalVS.xz, normalize(currSampledPosVS.xz - posVS.xz)) > 0)
			//{
			//	collectedReflectionColor = tex2D(colorTexture, currUV, dx, dy);
			//	break;
			//}
		}
		//else
		{
			float val = dot(rayNormalVS.xz, normalize(currSampledPosVS.xz - posVS.xz));
			if(  val < 0 )
			{
				collectedReflectionColor = tex2D(colorTexture, currUV, dx, dy);
				break;
			}
		}

		
	}

	return collectedReflectionColor;
	*/


	float4 color =  tex2D(colorTexture, In.tex0).xyzw;
	float3 normalW = UnpackNormal(tex2D(normalTexture, In.tex0).xy).xyz;
	

	//float maxRange = 30.f;
	//float stepMultiplier = 1;

	float3 reflectDirW = normalize(reflect(In.viewRayW, normalize(normalW)).xyz) * c.stepLength;

	// Important, more fade when reflect vector facing camera
	float reflectFadeFactor = 1.f;
	float reflectViewZ = mul(reflectDirW, (float3x3)c.view).z * 1.f / c.stepLength;
	if(reflectViewZ < 0)
		reflectFadeFactor = abs(reflectViewZ);

	float depth = tex2D(depthTexture, In.tex0).r;
	if( depth == 1.0f)
		return color;

	reflectDirW *= c.maxRange;  // max trace range : "maxRange" world unit
	float3 posW = GetWorldPosition(c.camPos, In.viewRayW, depth).xyz;
	float4 collectedReflectionColor = float4(0,0,0,0);
	int count = (int)c.maxRange % 80; // TODO, max 80 iteration, 160 sample per pixel (haha)
	for(int i = 1; i < count; i++ )
	{
		float3 tracedPosW = posW + reflectDirW * (float)i / (float)count;
		float4 reflectSamplePosH = mul(float4(tracedPosW, 1.0f), c.viewProj).xyzw;
		reflectSamplePosH.xyz /= reflectSamplePosH.w;

		float2 currUV;
		currUV.x = ((reflectSamplePosH.x + 1.f) /  2.f);
		currUV.y = ((reflectSamplePosH.y - 1.f) / -2.f);

		if( currUV.x > 1 || currUV.x < 0 || currUV.y > 1 ||currUV.y < 0)
			break;

		float currSampledDepth = tex2D(depthTexture, currUV).r;
		float currTracedDepth = reflectSamplePosH.w / c.farPlane; //  div by farPlane

		if( currSampledDepth == 1.0f)
			break;

		// Ez a feltetel alapvetoen szarra se jo, TODO CSERELD LE
		if( (currTracedDepth > currSampledDepth) && (currTracedDepth - currSampledDepth < 0.0005) )
		{
			collectedReflectionColor = tex2D(colorTexture, currUV);
			// TODO FADE OUT
			break;
		}
	}

	return color + collectedReflectionColor * reflectFadeFactor * 0.2f; // TODO, glossiness

}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}