#include "common.cginc"

sampler2D colorTexture : register( s0 ) = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
 
sampler2D depthTexture : register( s1 ) = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D normalTexture : register( s2 ) = {
	MipFilter = POINT,
	MinFilter = POINT,
	MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

struct {
	float4x4	invViewProj;
	float4x4 	viewProj;
	float4x4 	view;
	float4x4 	invView;
	float3		camPos;
} c : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: POSITION;
	float2 tex0 	: TEXCOORD0;
	float3 viewRayW  : TEXCOORD1;
};


VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );

	float4 viewRay = Out.posH.x * c.invViewProj[0] + (Out.posH.y * c.invViewProj[1] + (c.invViewProj[2] + c.invViewProj[3]));

	Out.viewRayW = viewRay.xyz * (1.0f / viewRay.w);
	Out.viewRayW -= c.camPos;

	return Out;
}


float4 PS_MAIN(VS_OUT In) : COLOR0 {

	float4 color =  tex2D(colorTexture, In.tex0).xyzw;
	float3 normalW = UnpackNormal(tex2D(normalTexture, In.tex0).xy).xyz;
	

	float maxRange = 50.f;
	float stepMultiplier = 12;
	float3 reflectDirW = normalize(reflect(In.viewRayW, normalize(normalW)).xyz);

	// Important, more fade when reflect vector facing camera
	float reflectFactor = 0.022;
	//float reflectViewZ = mul(reflectDirW, (float3x3)c.view).z;
	//if(reflectViewZ < 0)
		//reflectFactor = abs(reflectViewZ);

	float depth = tex2D(depthTexture, In.tex0).r;
	if( depth == 1.0f)
		return color;

	reflectDirW *= maxRange;  // max trace range : "maxRange" world unit
	float3 posW = GetWorldPosition(c.camPos, In.viewRayW, depth).xyz;
	float4 collectedReflectionColor = float4(0,0,0,0);
	for(float i = 1.f; i < maxRange; i++ )
	{
		float3 tracedPosW = posW + reflectDirW * i / maxRange * stepMultiplier;
		float4 reflectSamplePosH = mul(float4(tracedPosW, 1.0f), c.viewProj).xyzw;
		reflectSamplePosH.xyz /= reflectSamplePosH.w;

		float2 currUV;
		currUV.x = ((reflectSamplePosH.x + 1.f) /  2.f);
		currUV.y = ((reflectSamplePosH.y - 1.f) / -2.f);

		if( currUV.x > 1 || currUV.x < 0 || currUV.y > 1 ||currUV.y < 0)
			break;

		float currSampledDepth = tex2D(depthTexture, currUV).r;
		float currTracedDepth = reflectSamplePosH.w / 2000.f; //  div by farPlane

		if( currSampledDepth == 1.0f)
			break;

		// Ez a feltetel alapvetoen szarra se jo, TODO CSERELD LE
		if( (currTracedDepth > currSampledDepth) && (currTracedDepth - currSampledDepth < 0.005) )
		{
			collectedReflectionColor = tex2D(colorTexture, currUV);
			//reflectFactor = 1 - (abs(currUV.x * 2 -1) + abs(reflectSamplePosH.y * -2 + 1)) / 2.0f;
			break;
		}
	}

	return color + collectedReflectionColor * reflectFactor;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}