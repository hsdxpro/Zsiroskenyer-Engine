
//float4x4 currWorldViewProj : register(c0);
/*
struct {
 float4x4 currWorldViewProj;
 float4x4 prevWorldViewProj;
 float2	  InvframeDeltaTimeDiv2DivInputRes;
} c : register(c0);
*/

 float4x4 currWorldViewProj : register(c0);
 float4x4 prevWorldViewProj : register(c4);
 float2	  InvframeDeltaTimeDiv2DivInputRes : register(c8);


struct VS_IN {
	float3 posL : POSITION;
};

struct VS_OUT {
	float4 posH : SV_POSITION;
	float2 currPosH : TEXCOORD0;
	float2 prevPosH : TEXCOORD1;
};

VS_OUT VS_MAIN(VS_IN In) {
	VS_OUT Out;

	//Out.posH = mul(float4(In.posL, 1.0f), c.currWorldViewProj); 
	
	Out.posH = In.posL.x * currWorldViewProj[0] + (
		       In.posL.y * currWorldViewProj[1] + (
	 	       In.posL.z * currWorldViewProj[2] + 
		       currWorldViewProj[3]));

	Out.currPosH = Out.posH.xy / Out.posH.w;

	float4 prevPosH = In.posL.x * prevWorldViewProj[0] + (
		       In.posL.y * prevWorldViewProj[1] + (
	 	       In.posL.z * prevWorldViewProj[2] + 
		       prevWorldViewProj[3]));

	Out.prevPosH = prevPosH.xyz / prevPosH.w;
	return Out;
}

float2 PS_MAIN(VS_OUT In) : COLOR0 { 
		//Out.prevPosH.xyz /= Out.prevPosH.w;
	// v   =             s               /       t;     result = pixels per second
	// Clamp the velocity, 1.0 depth make so large velocity that ruins the motion blur sampling
	return (In.currPosH.xy - In.prevPosH.xy) * InvframeDeltaTimeDiv2DivInputRes;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}