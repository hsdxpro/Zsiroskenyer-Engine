struct {
 float4x4 currWorldViewProj;
 float4x4 prevWorldViewProj;
 float2	  InvframeDeltaTimeDiv2DivInputRes;
} c : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 currPosH : SV_POSITION;
	float4 prevPosH : TEXCOORD0;
};

VS_OUT VS_MAIN(VS_IN In) {
	VS_OUT Out;


	Out.currPosH = In.posL.x * c.currWorldViewProj[0] + (
		       In.posL.y * c.currWorldViewProj[1] + (
	 	       In.posL.z * c.currWorldViewProj[2] + 
		       c.currWorldViewProj[3]));
	
	Out.prevPosH = In.posL.x * c.prevWorldViewProj[0] + (
		       In.posL.y * c.prevWorldViewProj[1] + (
	 	       In.posL.z * c.prevWorldViewProj[2] + 
		       c.prevWorldViewProj[3]));

	Out.prevPosH.xyz *= 1.0f / Out.prevPosH.w;

	return Out;
}

float2 PS_MAIN(VS_OUT In) : COLOR0 {

	// v   =             s               /       t;     result = pixels per second
	// Clamp the velocity, 1.0 depth make so large velocity that ruins the motion blur sampling
	return  (In.currPosH.xy - In.prevPosH.xy) * c.InvframeDeltaTimeDiv2DivInputRes;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}