sampler2D gBuffer0 : register(s0);
sampler2D gBuffer1 : register(s1);
sampler2D gBuffer2 : register(s2);

float4x4 invViewProj: register(c0);
float4 camPos : register(c4);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;
	float4 gBuff0 = tex2D(gBuffer0, In.tex0);
	float z = gBuff0.w;

	// Freakin world space position calculation from depth :)
	// Determine projected position
	float4 posH = float4(In.tex0.x * 2 - 1, (1 - In.tex0.y) * 2 - 1, z, 1.0f);
	// Inverse transform that to view space
	float4 posW = mul(posH, invViewProj);
	posW.xyz /= posW.w;
	
	Out.color = float4(posW) * tex2D(gBuffer0, In.tex0);
//	Out.color = tex2D(gBuffer0, In.tex0) * (1.0f / distance(posW, camPos));
	return Out;
};