sampler2D gBuffer0 : register(s0);
sampler2D gBuffer1 : register(s1);
sampler2D gBuffer2 : register(s2);
sampler2D depthBuffer : register(s3);

float4x4 invViewProj: register(c0);
float4 camPos : register(c4);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

float3 depthToWorldSpace(float depth, float2 texCoord)
{
	// World space pos from depth
	float4 posH = float4(texCoord.x * 2 - 1, (1 - texCoord.y) * 2 - 1, depth, 1.0f); // NDC space
	float4 posW = mul(posH, invViewProj);
	posW /= posW.w;
	return posW.xyz;
}

float3 GetPosition(float2 texCoord)
{
	return depthToWorldSpace(tex2D(depthBuffer, texCoord).r, texCoord);
}

float3 GetNormal(float2 texCoord)
{
	float2 packedNormal = tex2D(gBuffer1, texCoord);
	float3 normal;
	normal.x = packedNormal.r;
	normal.y = 2.0f*(packedNormal.g>0.0f ? packedNormal.g-0.5f:packedNormal.g+0.5f);
	normal.z = sqrt(clamp(1.0f - normal.x*normal.x - normal.y*normal.y, 0, 1)) * (packedNormal.g>0.0f ? 1.0f:-1.0f);
	return normal;
}


//PER_PIXEL SSAO összetevõ számolás
float doAmbientOcclusion(in float2 texcoord,in float2 delta_uv, in float3 pos1, in float3 norm1)
{

 float3 pos2 = GetPosition(texcoord + delta_uv);

 //HALO eltüntetése (próbálkozás) sajna csak pár helyzetben nagyon jó
 if(distance(pos1,pos2) > 8.0f)
 	return 1.0f;

 float3 diff = pos2 - pos1;
 float3 dir = normalize(diff);


//Két pixel között húzódó vektor( p2 -> p1) dot p1 normal vektora,
//return 1.0f - saturate(dot(dir,norm1));///(SSAObias+length(diff));

float SSAObias = 0.0f;
return 1.0f -  clamp(dot(dir,norm1),0.05f,1.0f);///(SSAObias+length(diff));

}

//THE SSAO PROCESS FOR THE PIXEL
float ambientocclusionprocess(float2 projtex)
{
  float SSAOraylength = 4.0f;
  float SSAOiterations = 8;

//Ambient Gyüjtés folyamat kezdete 0
 float ao = 0.0f;
 float SMAP_DX = 1.0f/800.0f;//bbwidth;
 float SMAP_DY = 1.0f/600.0f;//bbheight;
                                                   //  . .
//Kiindulási pixel, normalja,pozíciója, és majd ezek körül mászkálunk négyzetekben..     . <- kiindulási pont
 float3 refpos = GetPosition(projtex);
 float3 refnorm = GetNormal(projtex);

 for (int j = 1; j <= SSAOiterations; ++j)
 {
   //8 körül levõ ponton mintavétel
   //kezdés bal felsõ sarok órajárás irányban..
   float2 coord1 = float2(-SMAP_DX,-SMAP_DY)*j*SSAOraylength;
   float2 coord2 = float2(0       ,-SMAP_DY)*j*SSAOraylength;
   float2 coord3 = float2(SMAP_DX ,-SMAP_DY)*j*SSAOraylength;
   float2 coord4 = float2(SMAP_DX ,0       )*j*SSAOraylength;
   float2 coord5 = float2(SMAP_DX ,SMAP_DY )*j*SSAOraylength;
   float2 coord6 = float2(0       ,SMAP_DY )*j*SSAOraylength;
   float2 coord7 = float2(-SMAP_DX,SMAP_DY )*j*SSAOraylength;
   float2 coord8 = float2(-SMAP_DX,0       )*j*SSAOraylength;


   ao+= doAmbientOcclusion(projtex,coord1,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord2,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord3,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord4,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord5,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord6,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord7,refpos,refnorm);
   ao+= doAmbientOcclusion(projtex,coord8,refpos,refnorm);


 } 
float SSAOintensity = 0.7f;
  return (1.0f - (ao/SSAOiterations/8))*(SSAOintensity);
}

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;
	
	float4 gBuff0 = tex2D(gBuffer0, In.tex0);
	float z = tex2D(depthBuffer , In.tex0).r;

	// World space pos from depth
	float3 posW = depthToWorldSpace(z, In.tex0);

	float3 normal = GetNormal(In.tex0);
		
	// calculate outputs color
	Out.color = 20.0f / distance(camPos.xyz, posW.xyz) * tex2D(gBuffer0, In.tex0);// * (20.0f / distance(camPos, posW));//posW;//tex2D(gBuffer0, In.tex0);
	
	
	// DEBUG INCOMING NORMALS!
	/*
	float lightness = Out.color.r*0.27+Out.color.g*0.67+Out.color.b*0.06;
	float4 lightnessColor = float4(float3(lightness, lightness, lightness)*0.4f, 0.f);
	Out.color = float4(normal+float3(1,1,1)*0.5, 1.f);
	*/
	Out.color = float4(normal*0.5+float3(0.5,0.5,0.5), 1);
	
	float4 dbgNormal = tex2D(gBuffer2, In.tex0);
	if (In.tex0.x>0.5)
		Out.color = dbgNormal;
	if (In.tex0.x>0.498 && In.tex0.x<0.502)
		Out.color = float4(0,0,0,1);
	
	float2 projtex = In.tex0 * 2 - 1;
	projtex.y *= -1;
	float ao = ambientocclusionprocess(In.tex0);

	//Out.color = float4(GetPosition(In.tex0),1);
	// Richard
	Out.color = 1 - ao;// * saturate(dot(normal, normalize(camPos- posW.xyz))) / distance(camPos, posW) * 15;
	//Out.color = tex2D(gBuffer0, In.tex0) * ao * clamp(saturate(dot(normal, normalize(camPos- posW))) / distance(camPos, posW) * 45, 0.0f, 1.5f);
	return Out;
};