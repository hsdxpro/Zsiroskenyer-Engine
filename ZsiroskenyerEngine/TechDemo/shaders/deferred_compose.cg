sampler2D gBuffer0 : register(s0);
sampler2D gBuffer1 : register(s1);
sampler2D gBuffer2 : register(s2);
sampler2D depthBuffer : register(s3);

float4x4 invProj: register(c0);
float4x4 invView: register(c4);
float4 camPos : register(c8);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;
	
	float4 gBuff0 = tex2D(gBuffer0, In.tex0);
	float z = tex2D(depthBuffer , In.tex0).r;

	// calculate world space position of pixel
	// clip space position
	float4 posH = float4(In.tex0.x * 2 - 1, (1 - In.tex0.y) * 2 - 1, z, 1.0f);
	// transfrom from clip space to world space w/ inverse proj matrix
	float4 posW = mul(posH, invProj);
	posW.xyz /= posW.w;
	posW.w = 1.0f;
	posW = mul(posW, invView);

	// get normal
	float2 packedNormal = tex2D(gBuffer1, In.tex0);
	float3 normal;
	normal.x = packedNormal.r;
	normal.y = 2.0f*(packedNormal.g>0.0f ? packedNormal.g-0.5f:packedNormal.g+0.5f);
	normal.z = sqrt(1.0f - normal.x*normal.x - normal.y*normal.y) * (packedNormal.g>0.0f ? 1.0f:-1.0f);
	
	// get debug normal
	float4 dbgNormal = tex2D(gBuffer2, In.tex0);
	
	// calculate outputs color
	Out.color = 20.0f / distance(camPos.xyz, posW.xyz) * tex2D(gBuffer0, In.tex0);// * (20.0f / distance(camPos, posW));//posW;//tex2D(gBuffer0, In.tex0);
	
	
	// DEBUG INCOMING NORMALS!
	/*
	float lightness = Out.color.r*0.27+Out.color.g*0.67+Out.color.b*0.06;
	float4 lightnessColor = float4(float3(lightness, lightness, lightness)*0.4f, 0.f);
	Out.color = float4(normal+float3(1,1,1)*0.5, 1.f);
	
	if (In.tex0.x>0.5)
		Out.color = dbgNormal;
	if (In.tex0.x>0.49 && In.tex0.x<0.51)
		Out.color = float4(0,0,0,1);
	*/
	
	return Out;
};