////////////////////////////////////////////////////////////////////////////////
//	Lighting shader for DIRECTIONAL lights
//
////////////////////////////////////////////////////////////////////////////////

#include "deferred_lightpass_cmn.cginc"

//------------------------------------------------------------------------------
//	Shadow maps
//------------------------------------------------------------------------------

#define NUM_MAX_CASCADES 12

sampler2D shadowMap = {
	MipFilter = LINEAR,
	MinFilter = LINEAR,
	MagFilter = LINEAR,
	AddressU = Wrap,
	AddressV = Wrap,
};

struct {
	float4x4 lightViewProj[NUM_MAX_CASCADES];
	int nCascades;
	bool castShadows;
} shadowConst : register(c100);

static const float3 DEBUG_CASCADE_COLOR[NUM_MAX_CASCADES] = {
	float3(0.2f, 1.0f, 0.2f), // green
	float3(1.0f, 0.5f, 0.2f), // orange
	float3(0.7f, 0.2f, 1.0f), // purple
	float3(0.95f, 0.95f, 0.1f), // yellow
	float3(0.2f, 0.95f, 0.95f), // cyan
	float3(0.6f, 0.45f, 0.3f), // brown
	float3(0.3f, 0.3f, 0.9f), // blue
	float3(1.0f, 0.2f, 0.2f), // red
	float3(0.5f, 0.95f, 0.15f), // greenish yellow
	float3(0.95f, 0.2f, 0.5f), // reddish pink
	// repeat ------------------------------------
	float3(0.2f, 1.0f, 0.2f), // green
	float3(1.0f, 0.5f, 0.2f), // orange
};

//------------------------------------------------------------------------------
//	Vertex shader
//------------------------------------------------------------------------------

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};
struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}


//------------------------------------------------------------------------------
//	Pixel shader
//------------------------------------------------------------------------------
float4 PS_MAIN(VS_OUT In) : COLOR0 {
	float4 color;
	float3 normal;
	float3 worldPos;
	float3 diffuseColor;
	float depth;
	DecodeGBuffer(In.tex0, diffuseColor, normal, worldPos, depth);
	
	// calculate lighting terms
	float3 diffuseTerm = DiffuseLight(lightDir, lightColor, normal);
	float3 specTerm = SpecularLight(lightColor, -lightDir, normal, normalize(worldPos - camPos), 0.2f);

	color.rgb += diffuseTerm*diffuseColor + specTerm; // note: no light attenuation
	color.a = 1.0f;

	// shadow map test
	/*
	if (In.tex0.x < 0.5f) {
		float shadowDepth = tex2D(shadowMap, In.tex0);
		color = float4(shadowDepth, shadowDepth, shadowDepth, 1.0f);
		return color;
	}
	*/

	// shadow map
	float3 shadowPos;

	// determine wich cascade
	/*
	int cascadeIdx = -1;
	for (int i=0; i<shadowConst.nCascades; i++) {
		float3 p =  mul(float4(worldPos, 1.0f), shadowConst.lightViewProj[i]);
		bool isInside = ((-1.0f < p.x && p.x < 1.0f) && 
						(-1.0f < p.y && p.y < 1.0f) &&
						(0.0f < p.z && p.z < 1.0f));
		if (isInside && cascadeIdx==-1) {
			cascadeIdx = i;
			shadowPos = p;
		}
	}
	color.rgb = DEBUG_CASCADE_COLOR[cascadeIdx]*0.99f + color.rgb*0.01f;
	//*/
	shadowPos = mul(float4(worldPos, 1.0f), shadowConst.lightViewProj[0]);
	if (-1.0f < shadowPos.x && shadowPos.x < 1.0f &&
		-1.0f < shadowPos.y && shadowPos.y < 1.0f &&
		 0.0f < shadowPos.z && shadowPos.z < 1.0f &&
		 shadowConst.castShadows)
	{
		float2 sampleCoord = float2(shadowPos.x*0.5f+0.5f, -shadowPos.y*0.5f+0.5f);
		/*
		float shadowSample = tex2Dproj(shadowMap, float4(sampleCoord.x, -sampleCoord.y, shadowPos.z, 1.0f)).r;
		color *= saturate(shadowSample);
		*/
		
		float shadowSample = tex2D(shadowMap, sampleCoord);
		if (shadowSample+1e-5 < shadowPos.z)
			discard;
		//*/
	}
	//*/
	return color;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}