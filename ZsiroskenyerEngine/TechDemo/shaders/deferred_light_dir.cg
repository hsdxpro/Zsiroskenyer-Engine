////////////////////////////////////////////////////////////////////////////////
//	Lighting shader for DIRECTIONAL lights
//
////////////////////////////////////////////////////////////////////////////////

#include "deferred_lightpass_cmn.cginc"

//------------------------------------------------------------------------------
//	Shadow maps
//------------------------------------------------------------------------------
sampler2D shadowMap = {
    MipFilter = LINEAR,
    MinFilter = LINEAR,
    MagFilter = LINEAR,
};
struct {
	float4x4 lightViewProj;
	bool castShadows;
} shadowConst : register(c100);

//------------------------------------------------------------------------------
//	Vertex shader
//------------------------------------------------------------------------------

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};
struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}


//------------------------------------------------------------------------------
//	Pixel shader
//------------------------------------------------------------------------------
float4 PS_MAIN(VS_OUT In) : COLOR0 {
	float4 color;
	float3 normal;
	float3 worldPos;
	float3 diffuseColor;
	float depth;
	DecodeGBuffer(In.tex0, diffuseColor, normal, worldPos, depth);
	
	// calculate lighting terms
	float3 diffuseTerm = DiffuseLight(lightDir, lightColor, normal);
	float3 specTerm = SpecularLight(lightColor, -lightDir, normal, normalize(worldPos - camPos), 0.2f);

	color.rgb += diffuseTerm*diffuseColor + specTerm; // note: no light attenuation
	color.a = 1.0f;

	// shadow map test
	/*
	if (In.tex0.x < 0.5f) {
		float shadowDepth = tex2D(shadowMap, In.tex0);
		color = float4(shadowDepth, shadowDepth, shadowDepth, 1.0f);
		return color;
	}
	*/

	// shadow map sampling
	float3 shadowPos = mul(float4(worldPos, 1.0f), shadowConst.lightViewProj);
	if (-1.0f < shadowPos.x && shadowPos.x < 1.0f &&
		-1.0f < shadowPos.y && shadowPos.y < 1.0f &&
		 0.0f < shadowPos.z && shadowPos.z < 1.0f &&
		 shadowConst.castShadows)
	{
		float2 sampleCoord = float2(shadowPos.x*0.5f+0.5f, -shadowPos.y*0.5f+0.5f);
		/*
		float shadowSample = tex2Dproj(shadowMap, float4(shadowPos, 1.0f)).r;
		color *= saturate(shadowSample);
		/*/
		float shadowSample = tex2D(shadowMap, sampleCoord);
		if (shadowSample+1e-5 < shadowPos.z)
			discard;
		//*/		
	}
	
	return color;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}