////////////////////////////////////////////////////////////////////////////////
//	Lighting shader for DIRECTIONAL lights
//
////////////////////////////////////////////////////////////////////////////////

#include "deferred_lightpass_cmn.cginc"

//------------------------------------------------------------------------------
//	Shadow maps
//------------------------------------------------------------------------------

#define NUM_MAX_CASCADES 12

sampler2D shadowMap = {
	MipFilter = LINEAR,
	MinFilter = LINEAR,
	MagFilter = LINEAR,
	AddressU = Wrap,
	AddressV = Wrap,
};

struct {
	float4x4 lightViewProj[NUM_MAX_CASCADES];
	int nCascades;
	bool castShadows;
} shadowConst : register(c100);

static const float3 DEBUG_CASCADE_COLOR[NUM_MAX_CASCADES] = {
	float3(0.2f, 1.0f, 0.2f), // green
	float3(1.0f, 0.5f, 0.2f), // orange
	float3(0.7f, 0.2f, 1.0f), // purple
	float3(0.95f, 0.95f, 0.1f), // yellow
	float3(0.2f, 0.95f, 0.95f), // cyan
	float3(0.6f, 0.45f, 0.3f), // brown
	float3(0.3f, 0.3f, 0.9f), // blue
	float3(1.0f, 0.2f, 0.2f), // red
	float3(0.5f, 0.95f, 0.15f), // greenish yellow
	float3(0.95f, 0.2f, 0.5f), // reddish pink
	// repeat ------------------------------------
	float3(0.2f, 1.0f, 0.2f), // green
	float3(1.0f, 0.5f, 0.2f), // orange
};

sampler2DARRAY shadowMap_Array = {
	MipFilter = LINEAR,
	MinFilter = LINEAR,
	MagFilter = LINEAR,
	AddressU = Wrap,
	AddressV = Wrap,
};

//------------------------------------------------------------------------------
//	Vertex shader
//------------------------------------------------------------------------------

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};
struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT vout;
	vout.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	vout.posH = float4(  vout.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return vout;
}


//------------------------------------------------------------------------------
//	Pixel shader
//------------------------------------------------------------------------------
float4 PS_MAIN(VS_OUT In) : COLOR0 {
	float4 color;
	float3 normal;
	float3 worldPos;
	float3 diffuseColor;
	float depth;
	DecodeGBuffer(In.tex0, diffuseColor, normal, worldPos, depth);
	
	// calculate lighting terms
	float3 viewDir = normalize(worldPos - camPos);
	float3 diffuseTerm = DiffuseLight(lightDir, lightColor, normal);
	float3 specTerm = SpecularLight(lightColor, -lightDir, normal, viewDir, 0.2f);

	color.rgb += diffuseTerm*diffuseColor + specTerm; // note: no light attenuation
	color.a = 1.0f;

	// shadow map
	float3 shadowPos;

	// determine wich cascade	
	int cascadeIdx = -1;
	for (int i=0; i<shadowConst.nCascades; i++) {
		float3 p =  mul(float4(worldPos, 1.0f), shadowConst.lightViewProj[i]);
		bool isInside = ((-1.0f < p.x && p.x < 1.0f) && 
						(-1.0f < p.y && p.y < 1.0f) &&
						(0.0f < p.z && p.z < 1.0f));
		if (isInside && cascadeIdx==-1) {
			cascadeIdx = i;
			shadowPos = p;
		}
	}
	//color.rgb = DEBUG_CASCADE_COLOR[cascadeIdx]*0.5f + color.rgb*0.5f; 
	

	if (shadowConst.castShadows) {
		float2 sampleCoord = float2(shadowPos.x*0.5f+0.5f, -shadowPos.y*0.5f+0.5f);

		// simple
		/*
		float shadowSample = tex2DARRAY(shadowMap_Array, float(sampleCoord, (float)cascadeIdx));
		
		if (shadowSample + 1e-5*exp((float)cascadeIdx) < shadowPos.z)
			discard;
		*/

		// pcf
		float u = sampleCoord.x;
		float v = sampleCoord.y;
		u = u * 2048.0f - 0.5f;
		v = v * 2048.0f - 0.5f;
		int x = u;
		int y = v;
		float u_ratio = u-x;
		float v_ratio = v-y;
		float u_opposite = 1.0f - u_ratio;
		float v_opposite = 1.0f - v_ratio;

		float4 lookup;
		lookup.x = (tex2DARRAY(shadowMap_Array, float3(x/2048.f,y/2048.f, (float)cascadeIdx))		+ 1e-5*exp((float)cascadeIdx)) < shadowPos.z ? 0 : 1;
		lookup.y = (tex2DARRAY(shadowMap_Array, float3((x+1)/2048.f,y/2048.f, (float)cascadeIdx))	+ 1e-5*exp((float)cascadeIdx)) < shadowPos.z ? 0 : 1;
		lookup.z = (tex2DARRAY(shadowMap_Array, float3(x/2048.f,(y+1)/2048.f, (float)cascadeIdx))	+ 1e-5*exp((float)cascadeIdx)) < shadowPos.z ? 0 : 1;
		lookup.w = (tex2DARRAY(shadowMap_Array, float3((x+1)/2048.f,(y+1)/2048.f, (float)cascadeIdx))	+ 1e-5*exp((float)cascadeIdx)) < shadowPos.z ? 0 : 1;

		float weight = 
			(lookup.x * u_opposite + lookup.y * u_ratio) * v_opposite +
			(lookup.z * u_opposite + lookup.w * u_ratio) * v_ratio;

		color.rgb *= weight;

	}

	return color;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}