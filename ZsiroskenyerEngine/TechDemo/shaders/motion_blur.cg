sampler2D textureInput = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D depthTexture = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

float4x4 invViewProj	: register(c0); // inv curr
float4x4 prevViewProj	: register(c4); // prev
float	 deltaT			: register(c8);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;
	// World space pos from depth (SLOW SOLUTION) TODO make faster
	float4 currPosH = float4(In.tex0.x * 2 - 1, (1 - In.tex0.y) * 2 - 1, tex2D(depthTexture , In.tex0).r, 1.0f); // NDC space
	float4 posW = mul(currPosH, invViewProj);
	posW.xyzw /= posW.w;

	float4 prevPosH = mul(posW, prevViewProj);
	prevPosH.xyzw /= prevPosH.w;
	
	float2 velocity = (currPosH.xy - prevPosH.xy) / 2.0f / deltaT;

	// Get the initial color at this pixel.  
   	float4 color = tex2D(textureInput, In.tex0);
	float alpha = color.a;

	int nSamples = 8;
	for(int i = 1; i < nSamples; ++i)     
		color += tex2D(textureInput, In.tex0 + i * velocity);
 
	Out.color = color / nSamples;
	Out.color.a = alpha;
	return Out;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}