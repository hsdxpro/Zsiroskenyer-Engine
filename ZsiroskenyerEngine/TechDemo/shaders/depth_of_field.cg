#include "common.cginc"

sampler2D inputTexture = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D depthTexture = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

float4x4 invViewProj;
float3	 camPos;

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;

	/*
	float avgRefDepth = 0;

	avgRefDepth += tex2D(depthTexture, float2(0.45f, 0.45f));
	avgRefDepth += tex2D(depthTexture, float2(0.55f, 0.55f));
	avgRefDepth += tex2D(depthTexture, float2(0.45f, 0.55f));
	avgRefDepth += tex2D(depthTexture, float2(0.55f, 0.45f));
	avgRefDepth /= 4;

	// Depth based component for bluring
	float depthComponent = abs(avgRefDepth - tex2D(depthTexture, In.tex0)) * 100;

	// Radial based component for bluring
	float radialComponent = pow(abs(In.tex0 * 2 - 1),3) * 0.61;

	// Bluring radius
	float radius = min((depthComponent  + radialComponent)*2.8,2.8f);
	//Out.color.rgb = float3(radius, radius, radius);
	//return Out;

	float4 color = tex2D(inputTexture, In.tex0);
	float alpha = color.a;
	int quality = 4;
	for( int i = 0; i < quality; i++)
	{
		color += tex2D(inputTexture, In.tex0 + float2(1.0f / 800, 0) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, 1.0f / 800) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, -1.0f / 800) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(-1.0f / 800, 0) * i * radius);
	}

	Out.color = color / (quality * 4 + 1);
	Out.color.a = alpha;
	*/

	
	float3 focusPointW = GetWorldPosition( In.tex0, tex2D(depthTexture, float2(0.5f, 0.5f)), invViewProj);
	float3 posW = GetWorldPosition( In.tex0, tex2D(depthTexture, In.tex0), invViewProj);

	// Distance from lens center to focus point
	float f = distance(focusPointW, camPos); // 0.01f bias to avoid divide by zero

	// Distance from lens center to object pos
	float t = distance(posW, camPos) + 0.001f;

	// Distance from lens center to "created" image
	float k = abs(f * t / abs((t - f)));

	// Diameter of our eye
	const float eyeDiameter = 1.02f;

	// CoC radius --> Coc is ( CoCRadius * CoCRadius * PI )
	float CoCRadius = eyeDiameter * (k - eyeDiameter) / (2 * k);
	CoCRadius /= (eyeDiameter / 2.0f);
	CoCRadius = (CoCRadius - 1.0f) * -1.0f;
	


	// Bluring radius
	float radius = CoCRadius * 2;
	//Out.color.rgb = radius;
	//return Out;

	float4 color = tex2D(inputTexture, In.tex0);
	float alpha = color.a;
	int quality = 54;
	for( int i = 0; i < quality; i++)
	{
		color += tex2D(inputTexture, In.tex0 + float2(1.0f / 800, 0)  * (float)i  / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, 1.0f / 800)  * (float)i  / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, -1.0f / 800) * (float)i / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2(-1.0f / 800, 0) * (float)i / quality * radius);
	}

	Out.color = color / (quality * 4 + 1);
	Out.color.a = alpha;

	return Out;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}