#include "common.cginc"

sampler2D inputTexture : register(s0) = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
 
sampler2D depthTexture : register(s1) = {
	MipFilter = LINEAR,
    	MinFilter = LINEAR,
    	MagFilter = LINEAR,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

float4x4 invViewProj;
float3	 camPos;

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};


VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}

float4 PS_MAIN(VS_OUT In) : COLOR0 {

	float3 focusPointW = GetWorldPosition( In.tex0, tex2D(depthTexture, float2(0.5f, 0.5f)), invViewProj);
	float3 posW = GetWorldPosition( In.tex0, tex2D(depthTexture, In.tex0), invViewProj);

	// Distance from lens center to focus point
	float f = distance(focusPointW, camPos); 

	// Distance from lens center to object pos
	float t = distance(posW, camPos) + 0.001f; // 0.01f bias to avoid divide by zero

	// Distance from lens center to "created" image
	float k = abs(f * t / abs((t - f)));

	// Diameter of our eye
	const float eyeDiameter = 1.02f;

	// CoC radius --> Coc is ( CoCRadius * CoCRadius * PI )
	float CoCRadius = eyeDiameter * (k - eyeDiameter) / (2 * k);
	CoCRadius /= (eyeDiameter / 2.0f);
	CoCRadius = (CoCRadius - 1.0f) * -1.0f;
	


	// Bluring radius
	float radius = CoCRadius * 2;

	float4 color = tex2D(inputTexture, In.tex0);
	return color;
	float alpha = color.a;
	//Out.color = color; 
	//Out.color.a = alpha;
	//return Out;

	int quality = 8; 
	for( int i = 1; i < quality; ++i)
	{
		color += tex2D(inputTexture, In.tex0 + float2(  1.0f / 800	,  0		  ) * (float)i  / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2(  0			,  1.0f / 800 ) * (float)i  / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2(  0			, -1.0f / 800 ) * (float)i  / quality * radius);
		color += tex2D(inputTexture, In.tex0 + float2( -1.0f / 800	,  0		  ) * (float)i  / quality * radius);
	}

	float4 finalColor = color / (quality * 4 + 1);
	finalColor.a = alpha;

	return finalColor;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}