sampler2D inputTexture;
sampler2D depthTexture;

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};

struct PS_OUT {
	float4 color: COLOR0;
};

VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}

PS_OUT PS_MAIN(VS_OUT In) {
	PS_OUT Out;
	float avgRefDepth = 0;

	avgRefDepth += tex2D(depthTexture, float2(0.45f, 0.45f));
	avgRefDepth += tex2D(depthTexture, float2(0.55f, 0.55f));
	avgRefDepth += tex2D(depthTexture, float2(0.45f, 0.55f));
	avgRefDepth += tex2D(depthTexture, float2(0.55f, 0.45f));
	avgRefDepth /= 4;

	// Depth based component for bluring
	float depthComponent = abs(avgRefDepth - tex2D(depthTexture, In.tex0)) * 100;

	// Radial based component for bluring
	float radialComponent = pow(abs(In.tex0 * 2 - 1),3) * 0.61;

	// Bluring radius
	float radius = min((depthComponent  + radialComponent)*2.8,2.8f);

	float4 color = tex2D(inputTexture, In.tex0);
	int quality = 4;
	for( int i = 0; i < quality; i++)
	{
		color += tex2D(inputTexture, In.tex0 + float2(1.0f / 800, 0) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, 1.0f / 800) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(0, -1.0f / 800) * i * radius);
		color += tex2D(inputTexture, In.tex0 + float2(-1.0f / 800, 0) * i * radius);
	}

	Out.color = color / (quality * 4 + 1);

	return Out;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}