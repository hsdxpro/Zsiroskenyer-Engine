#include "common.cginc"

sampler2D inputTexture = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
 
sampler2D depthTexture = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D adaptedFocalPlaneTex = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

struct {
	float4x4	invViewProj;
	float3		camPos;
	float		frameDeltaTime; // just shader :depth_of_field_focal_plane_adaption  use it
	float		invRetinaRadiusProductInputTexWidth;
	float		invTexWidth;
	float		invTexHeight;
	float		minusInvTexWidth;
	float		minusInvTexHeight;
	float		aperture;
	float		retinaLensDist;
} cBuffer : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: SV_POSITION;
	float2 tex0 	: TEXCOORD2;
};


VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );
	return Out;
}

float4 PS_MAIN(VS_OUT In) : COLOR0 {
	// The plane that we choose in focus (currently adapted across frames in depth_of_field_focal_plane_adaption shader
	float focusedPointDist = tex2D(adaptedFocalPlaneTex, float2(0.5f, 0.5f)).r;

	// Then we calculate the belonging focal length to our eye
	float focalLength = cBuffer.retinaLensDist * focusedPointDist / (cBuffer.retinaLensDist + focusedPointDist);

	// Current pixel distance from camera
	float pointDist = distance(cBuffer.camPos, GetWorldPosition( In.tex0, tex2D(depthTexture, In.tex0).r, cBuffer.invViewProj));

	// Calculate Circle Of Confusion
	float CoC = abs(cBuffer.aperture * focalLength * (focusedPointDist - pointDist) * (1.0f / ( pointDist * (focusedPointDist - focalLength))));

	// Interesting example : CoC * (1.0f / ~retinaRadius) * inputTextureWidth;
	// The first product normalizes te CoC to our retina, so the result will be [0,1] then scale this by input texture width
	float blurRadius = CoC * cBuffer.invRetinaRadiusProductInputTexWidth;

	float4 color = tex2D(inputTexture, In.tex0);
	float alpha = color.a;

	float quality = 6; 
	for( float i = 1; i < quality; ++i)
	{
		float blurAmount = i  / quality * blurRadius;
		color += tex2D(inputTexture,  float2(  cBuffer.invTexWidth		,  0						 ) * blurAmount + In.tex0);
		color += tex2D(inputTexture,  float2(  0						,  cBuffer.invTexHeight		 ) * blurAmount + In.tex0);
		color += tex2D(inputTexture,  float2(  0						,  cBuffer.minusInvTexHeight ) * blurAmount + In.tex0);
		color += tex2D(inputTexture,  float2(  cBuffer.minusInvTexWidth ,  0						 ) * blurAmount + In.tex0);
	}

	float4 finalColor = color * (1.0f / ((quality - 1) * 4 + 1));
	finalColor.a = alpha;

	return finalColor;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}