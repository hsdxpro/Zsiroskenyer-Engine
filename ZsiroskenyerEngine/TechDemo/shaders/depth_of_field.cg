#include "common.cginc"

sampler2D inputTexture = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};
 
sampler2D depthTexture = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

sampler2D adaptedFocalPlaneTex = {
	MipFilter = POINT,
    MinFilter = POINT,
    MagFilter = POINT,
	AddressU = CLAMP,
	AddressV = CLAMP,
};

struct {
	float4x4	invViewProj;
	float3		camPos;
	float		frameDeltaTime; // just shader :depth_of_field_focal_plane_adaption  use it
	float		invRetinaRadiusProductInputTexWidth;
	float		invTexWidth;
	float		invTexHeight;
	float		minusInvTexWidth;
	float		minusInvTexHeight;
	float		aperture;
	float		retinaLensDist;
} c : register(c0);

struct VS_IN {
	float3 posL 	: POSITION;
	float2 tex0 	: TEXCOORD0;
};

struct VS_OUT {
	float4 posH 	: POSITION;
	float2 tex0 	: TEXCOORD0;
	float3 viewRay  : TEXCOORD1;
};


VS_OUT VS_MAIN(VS_IN In, uint VertexID : VERTEXID) {
	VS_OUT Out;
	Out.tex0 = float2( (VertexID << 1) & 2, VertexID & 2 );
	Out.posH = float4(  Out.tex0 * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f), 0.0f, 1.0f );

	float4 viewRay =	Out.posH.x * c.invViewProj[0] + (
						Out.posH.y * c.invViewProj[1] + (
						c.invViewProj[2] +
						c.invViewProj[3]));

	Out.viewRay = viewRay.xyz * (1.0f / viewRay.w);
	Out.viewRay -= c.camPos;

	return Out;
}


float4 PS_MAIN(VS_OUT In) : COLOR0 {
	// The plane that we choose in focus (currently adapted across frames in depth_of_field_focal_plane_adaption shader
	float focusedPointDist = tex2D(adaptedFocalPlaneTex, float2(0.5f, 0.5f)).r;

	// Then we calculate the belonging focal length to our eye
	float focalLength = c.retinaLensDist * focusedPointDist / (c.retinaLensDist + focusedPointDist);

	float3 posW = GetWorldPosition(c.camPos, In.viewRay, tex2D(depthTexture, In.tex0));

	// Current pixel distance from camera
	float pointDist = distance(c.camPos, posW);

	// Calculate Circle Of Confusion
	float CoC = abs(c.aperture * focalLength * (focusedPointDist - pointDist) * (1.0f / ( pointDist * (focusedPointDist - focalLength))));

	// Interesting example : CoC * (1.0f / ~retinaRadius) * inputTextureWidth;
	// The first product normalizes te CoC to our retina, so the result will be [0,1] then scale this by input texture width
	float blurCircleDiameter = CoC * c.invRetinaRadiusProductInputTexWidth;

	float4 color = tex2D(inputTexture, In.tex0);
	float alpha = color.a; // Save alpha

	const float2 poissonDisk[8] = {
		float2(	 -0.0914861f / 2.0f,	-0.9040616f / 2.0f ),
		float2(	 -0.7357999f / 2.0f,	-0.4860847f / 2.0f ),
		float2(	  0.0052135f / 2.0f,	-0.1503162f / 2.0f ),
		float2(	 -0.6150167f / 2.0f,	 0.2418161f / 2.0f ),
		float2(	  0.9692842f / 2.0f,	-0.1548799f / 2.0f ),
		float2(	  0.3041316f / 2.0f,	 0.5059290f / 2.0f ),
		float2(	 -0.3363325f / 2.0f,	 0.9149118f / 2.0f ),
		float2(	  0.5941941f / 2.0f,	-0.7803356f / 2.0f )
	};

	// Warning MAX QUALITY = 7, because poisson rotation based on poissonDisk[8];

	const float quality = 4; // 4 means 3 circle sample..

	// Each quality iteration rotates poisson disk
	float2x2 poissonRot;
	for(float i = 1; i < quality; i++)
	{
		poissonRot = float2x2(	float2(cos(poissonDisk[i + 0].x + In.tex0.x), -sin(poissonDisk[i + 0].y + In.tex0.y)), 
								float2(sin(poissonDisk[i + 1].x + In.tex0.x),  cos(poissonDisk[i + 1].y + In.tex0.y)));

		float2 ndcSpaceToTexcoordSpace =  float2(c.invTexWidth, c.invTexHeight) * ((i * blurCircleDiameter) * (1.0f / quality));

		for(int j = 0; j < 8; j++)
		{
			// Poisson disk based on poisson rotation sample coord :)
			float2 poissonOffset = mul(poissonDisk[j], poissonRot) * ndcSpaceToTexcoordSpace;
			color += tex2D(inputTexture, In.tex0 + poissonOffset);
		}
	}

	color /= (quality - 1) * 8 + 1; // 3 * 8 + 1 = 25 sample, this is constant so i think is compile time constant :)
	color.a = alpha; // Reset old alpha

	return color;
}

technique t
{
	pass p
	{
		VertexProgram = compile vs_4_0 VS_MAIN();
		FragmentProgram = compile ps_4_0 PS_MAIN();
	}
}